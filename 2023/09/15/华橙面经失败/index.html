<!DOCTYPE html>
<html>
  <head>
     
    <meta charset="UTF-8">
    <title>华橙面经失败 - 小孙的blog</title>
    <link rel="shortcut icon" href="/static/img/icon.png">
    <link rel="icon" href="/static/img/icon.png" sizes="192x192"/>
    
<link rel="stylesheet" href="/static/kico.css">
<link rel="stylesheet" href="/static/hingle.css">

    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">

    <meta name="viewport" content="width=device-width, maximum-scale=1, initial-scale=1"/>
    <meta property="og:site_name" content="小孙的blog">
    <meta property="og:title" content="华橙面经失败"/>
    
    <style>body:before{ content: ''; background-image: url(https://api.paugram.com/wallpaper?source=gh) }</style>
    
<meta name="generator" content="Hexo 6.3.0"></head>

  <body>
    <header>
    <div class="head-title">
        <h4>小孙的blog</h4>
    </div>
    <div class="head-action">
        <div class="toggle-btn"></div>
        <div class="light-btn"></div>
        <div class="search-btn"></div>
    </div>
    <form class="head-search" method="post">
        <input type="text" name="s" placeholder="搜索什么？">
    </form>
    <nav class="head-menu">
        <a href="/">首页</a>
        <div class="has-child">
            <a>分类</a>
            <div class="sub-menu">
                
            </div>
        </div>
        
            <a href="/about">关于我</a>
        
            <a href="/friends">朋友们</a>
        
    </nav>
</header>

    <main>
    <div class="wrap min">
        <section class="post-title">
            <h2>华橙面经失败</h2>
            <div class="post-meta">
                <time class="date">2023.09.15</time>
            
            </div>
        </section>
        <article class="post-content">
        
            <h2 id="简历上一知半解的一定不要写！！！"><a href="#简历上一知半解的一定不要写！！！" class="headerlink" title="简历上一知半解的一定不要写！！！"></a>简历上一知半解的一定不要写！！！</h2><h2 id="1-TS流与PS流"><a href="#1-TS流与PS流" class="headerlink" title="1.TS流与PS流"></a>1.TS流与PS流</h2><p>PS流（Program Stream）和 TS流（Transport Stream）都是数字视频编码的封装格式，主要用于流媒体的传输和存储。下面是它们的简要介绍：</p>
<ol>
<li><strong>PS流（Program Stream）</strong>:<ul>
<li>主要用于存储媒体，如DVD。</li>
<li>设计目标是为了在误差较少的通信或存储环境中工作。</li>
<li>PS流只能封装一个视频和一个音频，不适合传输多个音频或视频。</li>
<li>通常不包含额外的错误校正信息，因为它假设底层的存储或传输机制提供了相对可靠的数据传输。</li>
</ul>
</li>
<li><strong>TS流（Transport Stream）</strong>:<ul>
<li>主要用于数字电视广播和流媒体应用。</li>
<li>专为传输设计，在一个信道中可以传输多个音频、视频和数据流。</li>
<li>具有容错功能，因此更适用于可能出现数据丢失的环境，例如无线传输。</li>
<li>TS流可以包括额外的错误校正信息，使其更加适合于可能存在干扰的传输环境。</li>
</ul>
</li>
</ol>
<p>简而言之，PS流更适合于存储应用，而TS流设计得更适合于流媒体传输。在数字电视和其他流媒体应用中，TS流的容错和多路复用特性使其成为更受欢迎的选择。</p>
<h2 id="2-IO复用"><a href="#2-IO复用" class="headerlink" title="2.IO复用"></a>2.IO复用</h2><p>I&#x2F;O复用允许一个进程监视多个文件描述符（通常是网络套接字），以查看它们是否处于可读、可写或异常状态。</p>
<p>I&#x2F;O复用技术主要解决以下问题：如果你有多个I&#x2F;O操作，你如何不使用多线程或多进程，而只用一个线程或进程来同时等待所有的I&#x2F;O操作完成。</p>
<p>常用的I&#x2F;O复用技术包括：</p>
<ol>
<li><strong>select</strong>：<ul>
<li>最早和广泛支持的I&#x2F;O复用方法。</li>
<li>使用一个位掩码来表示你感兴趣的文件描述符和事件。</li>
<li>缺点是当监视的描述符数量增长时，效率降低，而且有文件描述符的数量限制。</li>
</ul>
</li>
<li><strong>poll</strong>：<ul>
<li>与select类似，但不受文件描述符数量的限制。</li>
<li>使用结构数组而不是位掩码来表示感兴趣的文件描述符。</li>
</ul>
</li>
<li><strong>epoll</strong>：<ul>
<li>Linux特有的I&#x2F;O复用解决方案，相对于select和poll，它更加高效。</li>
<li>它不是线性扫描所有文件描述符，而是通过回调机制来直接获得已经准备好的描述符。</li>
<li>使用内核和用户空间之间的共享内存来减少数据复制操作。</li>
</ul>
</li>
</ol>
<p>I&#x2F;O复用的优点：</p>
<ul>
<li>能够处理大量并发连接，而不需要为每个连接创建线程或进程。</li>
<li>节省了线程和进程创建、销毁的开销。</li>
<li>减少了上下文切换带来的开销。</li>
</ul>
<p>I&#x2F;O复用的缺点：</p>
<ul>
<li>对于某些高负载的短连接，使用专门的线程或进程可能会更高效。</li>
<li>需要更复杂的编程模型。</li>
</ul>
<h2 id="3-TCP和UDP"><a href="#3-TCP和UDP" class="headerlink" title="3.TCP和UDP"></a>3.TCP和UDP</h2><p>TCP（Transmission Control Protocol，传输控制协议）和UDP（User Datagram Protocol，用户数据报协议）是两种主要的、在互联网协议簇（IP）之上的传输层协议。它们有各自的特点和适用场景，以下是它们的主要区别和特性：</p>
<h3 id="TCP："><a href="#TCP：" class="headerlink" title="TCP："></a>TCP：</h3><ol>
<li><strong>连接导向</strong>：在数据传输之前，TCP要求建立一个连接。这通常是通过所谓的“三次握手”完成的。</li>
<li><strong>可靠性</strong>：TCP提供了数据包排序和确认机制，确保数据正确无误地从发送端传输到接收端。丢失的数据包将被重新发送。</li>
<li><strong>流量控制</strong>：TCP使用窗口机制来控制发送方和接收方之间的数据传输速率，从而防止接收方被发送方的数据淹没。</li>
<li><strong>拥塞控制</strong>：当网络中的数据包太多时，TCP会减少其数据发送速率。</li>
<li><strong>字节流</strong>：TCP将应用程序发送的数据视为一个连续的字节流，而没有边界。</li>
</ol>
<h3 id="UDP："><a href="#UDP：" class="headerlink" title="UDP："></a>UDP：</h3><ol>
<li><strong>无连接</strong>：UDP不需要建立连接，发送方可以直接发送数据。</li>
<li><strong>不可靠性</strong>：UDP不保证数据包的顺序，也不保证数据包的送达。因此，有可能数据包丢失、重复或乱序。</li>
<li><strong>无流量和拥塞控制</strong>：UDP没有提供流量控制或拥塞控制机制。</li>
<li><strong>数据报文</strong>：与TCP不同，UDP在应用程序之间发送和接收有明确边界的数据报文。</li>
<li><strong>低开销</strong>：因为UDP没有TCP那样复杂的控制机制，所以它通常具有更低的延迟和更高的吞吐量。</li>
</ol>
<h3 id="适用场景："><a href="#适用场景：" class="headerlink" title="适用场景："></a>适用场景：</h3><p><strong>TCP</strong> 通常用于需要可靠性和数据完整性的应用，如Web浏览（HTTP&#x2F;HTTPS）、电子邮件（SMTP&#x2F;IMAP&#x2F;POP3）、文件传输（FTP）等。</p>
<p><strong>UDP</strong> 通常用于不需要每个数据包都得到确认的应用，或者那些自己在应用层实现了错误恢复机制的应用，如实时音频&#x2F;视频流（VoIP、IPTV）、域名系统（DNS）查询、网络游戏等。</p>
<p>总之，选择TCP还是UDP取决于应用的需求：是需要可靠性和数据完整性，还是低延迟和高吞吐量。</p>
<h2 id="4-sizeof与strlen，size（）"><a href="#4-sizeof与strlen，size（）" class="headerlink" title="4.sizeof与strlen，size（）"></a>4.sizeof与strlen，size（）</h2><ul>
<li><code>sizeof</code> 是一个关于内存空间大小的运算符（会统计字符串的结束符）。（字节数）</li>
<li><code>strlen</code> 是一个关于C风格字符串长度的函数。</li>
<li><code>size()</code>与length() 效果相同，size()是一个关于C++ STL容器中元素数量的成员函数。</li>
</ul>
<h2 id="5-线程和进程的区别"><a href="#5-线程和进程的区别" class="headerlink" title="5.线程和进程的区别"></a>5.线程和进程的区别</h2><p>1.一个进程可以有多个线程</p>
<p>2.<strong>资源分配</strong>:</p>
<ul>
<li><strong>进程</strong>: 每个进程都有自己的独立的内存和系统资源。</li>
<li><strong>线程</strong>: 线程共享其父进程的内存和系统资源。</li>
</ul>
<p>3.<strong>开销</strong>:</p>
<ul>
<li><strong>进程</strong>: 进程的创建、维护和终止都需要相对较大的开销。</li>
<li><strong>线程</strong>: 与进程相比，线程的创建、维护和终止的开销较小。</li>
</ul>
<p>4.<strong>通信</strong>:</p>
<ul>
<li><strong>进程</strong>: 进程间通信(IPC)相对复杂，通常需要使用管道、消息队列、套接字等机制。</li>
<li><strong>线程</strong>: 由于线程共享相同的地址空间，它们可以直接访问同一进程中的其他线程的数据结构，但需要使用同步原语（如互斥锁、信号量等）来防止并发问题。</li>
</ul>
<p>5.<strong>存储结构</strong>:</p>
<ul>
<li><strong>进程</strong>: 每个进程都有自己的单独的地址空间、全局变量、文件描述符等。</li>
<li><strong>线程</strong>: 所有线程共享同一个地址空间、全局变量等，但每个线程都有自己的程序计数器、寄存器、堆栈和状态。</li>
</ul>
<h2 id="6-变量存放"><a href="#6-变量存放" class="headerlink" title="6.变量存放"></a>6.变量存放</h2><ol>
<li><p><strong>栈（Stack）</strong>:</p>
<ul>
<li><strong>定义</strong>: 栈是一个后进先出（LIFO）的数据结构，用于存储局部变量。</li>
<li><strong>变量类型</strong>: 函数内部声明的局部变量、函数参数。</li>
<li><strong>生命周期</strong>: 这些变量在函数被调用时创建，并在函数返回时被销毁。</li>
<li><strong>注意</strong>: 栈的大小是有限的。如果你有一个需要大量内存的局部变量（例如，一个非常大的数组），可能会导致栈溢出。</li>
</ul>
</li>
<li><p><strong>堆（Heap）</strong>:</p>
<ul>
<li><strong>定义</strong>: 堆是用于动态内存分配的内存区域。</li>
<li><strong>变量类型</strong>: 通过 <code>new</code> (C++标准库中的 <code>malloc</code> 和相关函数) 分配的变量或对象。</li>
<li><strong>生命周期</strong>: 这些变量或对象在被明确删除（通过 <code>delete</code> 或 <code>free</code>）之前一直存在。</li>
<li><strong>注意</strong>: 未经管理的堆内存可能会导致内存泄漏。C++11及之后的版本引入了智能指针（如 <code>std::shared_ptr</code> 和 <code>std::unique_ptr</code>）来帮助管理动态分配的对象。</li>
</ul>
</li>
<li><p><strong>静态存储区域</strong>:</p>
<ul>
<li><strong>定义</strong>: 用于存储全局变量、静态变量和常量。</li>
<li><strong>变量类型</strong>: 在函数外部声明的变量（全局变量）、在函数内部或类中使用 <code>static</code> 修饰符声明的变量。</li>
<li><strong>生命周期</strong>: 这些变量在程序开始时创建，并在程序结束时销毁。</li>
</ul>
</li>
<li><p><strong>常量存储区域</strong>:</p>
<ul>
<li><strong>定义</strong>: 用于存储常量值，如字符串常量。</li>
<li><strong>变量类型</strong>: 使用 <code>const</code> 修饰符声明的变量。</li>
<li><strong>生命周期</strong>: 这些常量的生命周期取决于它们是如何声明的。例如，局部的 <code>const</code> 变量会存在于栈上，而全局的 <code>const</code> 变量会存在于静态存储区域。</li>
</ul>
</li>
<li><p><strong>线程存储持续性</strong>:</p>
<ul>
<li><strong>定义</strong>: C++11 引入了线程存储持续性，用于单个线程内的变量存储。</li>
<li><strong>变量类型</strong>: 使用 <code>thread_local</code> 修饰符声明的变量。</li>
<li><strong>生命周期</strong>: 这些变量在关联的线程的生命周期内存在。</li>
</ul>
<h2 id="7-锁"><a href="#7-锁" class="headerlink" title="7.锁"></a>7.锁</h2></li>
</ol>
<p>在C++中，多线程编程常常涉及到对共享资源的并发访问，这可能会导致数据不一致或其他意想不到的问题。为了确保资源安全地被多个线程访问，我们使用锁（或互斥量）来同步线程。</p>
<h2 id="8-容器迭代器失效问题"><a href="#8-容器迭代器失效问题" class="headerlink" title="8.容器迭代器失效问题"></a>8.容器迭代器失效问题</h2><p>在C++的STL容器中，迭代器失效是一个常见问题。当容器中的元素被修改、删除或新增时，已存在的迭代器可能会失效，即它们可能不再指向预期的元素或变得完全不可用。</p>
<h2 id="9-三次握手和四次挥手"><a href="#9-三次握手和四次挥手" class="headerlink" title="9.三次握手和四次挥手"></a>9.三次握手和四次挥手</h2><h2 id="1-三次握手（TCP连接建立）"><a href="#1-三次握手（TCP连接建立）" class="headerlink" title="1. 三次握手（TCP连接建立）"></a>1. 三次握手（TCP连接建立）</h2><p>三次握手的目的是在客户端和服务器之间建立一个可靠的连接。</p>
<ol>
<li><strong>SYN</strong>：客户端选择一个初始序列号x，并发送一个SYN（同步）数据包给服务器，询问是否可以打开一个连接。</li>
<li><strong>SYN + ACK</strong>：服务器收到SYN包后，选择一个初始序列号y，并发送一个SYN&#x2F;ACK（同步&#x2F;确认）数据包给客户端，确认收到了客户端的SYN请求，并提供自己的初始化序列号。</li>
<li><strong>ACK</strong>：客户端收到服务器的SYN&#x2F;ACK包后，向服务器发送一个ACK（确认）数据包，确认收到了服务器的初始化序列号。</li>
</ol>
<p>此时，客户端和服务器之间的TCP连接已经建立。</p>
<h2 id="2-四次挥手（TCP连接终止）"><a href="#2-四次挥手（TCP连接终止）" class="headerlink" title="2. 四次挥手（TCP连接终止）"></a>2. 四次挥手（TCP连接终止）</h2><p>四次挥手的目的是安全地关闭一个TCP连接。</p>
<ol>
<li><strong>FIN</strong>：当数据发送完毕，客户端发送一个FIN（结束）数据包给服务器，表示希望关闭连接。</li>
<li><strong>ACK</strong>：服务器收到FIN包后，发送一个ACK（确认）数据包给客户端，确认收到了关闭请求。但此时服务器可能还有数据需要发送，所以并不立刻关闭连接。</li>
<li><strong>FIN</strong>：当服务器发送完所有数据后，发送另一个FIN数据包给客户端，告诉它我也准备好关闭连接了。</li>
<li><strong>ACK</strong>：客户端收到服务器的FIN包后，发送一个ACK（确认）数据包给服务器，确认知道服务器已准备好关闭连接。</li>
</ol>
<p>在此之后，客户端和服务器之间的TCP连接被成功终止。</p>
<p>这个机制确保了双方都可以安全、可靠地建立和终止连接。</p>
<h2 id="10-七层网络模型和五层"><a href="#10-七层网络模型和五层" class="headerlink" title="10.七层网络模型和五层"></a>10.七层网络模型和五层</h2><p>计算机网络模型是一个理论框架，用于描述计算机网络中的操作和交互。最著名的网络模型有两个：OSI（开放系统互连）模型和TCP&#x2F;IP模型。</p>
<ol>
<li><p><strong>OSI七层模型</strong>：</p>
<ul>
<li>**应用层 (Application Layer)**：为应用程序提供网络服务，并定义了与其他应用程序的通信规则。</li>
<li>**表示层 (Presentation Layer)**：负责数据格式转换、数据加密等任务，确保数据从一个系统传输到另一个系统时仍然保持其意义。</li>
<li>**会话层 (Session Layer)**：负责建立、管理和终止通信会话。</li>
<li>**传输层 (Transport Layer)**：为两台计算机之间的数据通信提供端到端的服务。主要协议有TCP和UDP。</li>
<li>**网络层 (Network Layer)**：决定数据的路径选择和逻辑地址（如IP地址）。常见的协议有IP、ICMP、IGMP等。</li>
<li>**数据链路层 (Data Link Layer)**：定义了如何在通信的实体之间传输数据。这层被分为两个子层：逻辑链路控制(LLC) 和 媒介访问控制(MAC)。</li>
<li>**物理层 (Physical Layer)**：定义了与网络媒体的物理连接相关的特性，如电压、时钟频率等。</li>
</ul>
</li>
<li><p><strong>TCP&#x2F;IP五层模型</strong>（也有些资料描述为四层模型）：</p>
<ul>
<li>**应用层 (Application Layer)**：与OSI模型的应用层、表示层和会话层对应。负责为应用程序提供网络服务，处理高层协议，例如HTTP、FTP、SMTP等。</li>
<li>**传输层 (Transport Layer)**：与OSI模型的传输层对应。主要协议有TCP和UDP。</li>
<li>**网络层 (Network Layer)**：与OSI模型的网络层对应。负责数据包的路由和转发。常见的协议有IP。</li>
<li>**数据链路层 (Data Link Layer)**：与OSI模型的数据链路层对应。定义了如何在通信的实体之间传输数据。</li>
<li>**物理层 (Physical Layer)**：与OSI模型的物理层对应。定义了与网络媒体的物理连接相关的特性。</li>
</ul>
<h2 id="11-进程调度算法"><a href="#11-进程调度算法" class="headerlink" title="11.进程调度算法"></a>11.进程调度算法</h2><p>进程调度是操作系统中负责决定哪个可用的进程应当分配给可用的CPU的部分。以下是一些常用的进程调度算法：</p>
<ol>
<li><strong>先来先服务 (FCFS, First-Come-First-Serve)</strong><ul>
<li>最简单的调度算法</li>
<li>依据进程到达的顺序进行调度</li>
<li>可能导致“饥饿”情况，即某些进程长时间得不到执行</li>
</ul>
</li>
<li><strong>最短作业优先 (SJF, Shortest Job First)</strong><ul>
<li>选择最短执行时间的进程进行调度</li>
<li>如果多个进程具有相同的运行时间，则采用FCFS</li>
<li>也可能导致“饥饿”</li>
</ul>
</li>
<li><strong>轮转法 (Round Robin, RR)</strong><ul>
<li>每个进程被分配一个固定大小的时间片或量程</li>
<li>进程的执行被限制在这个时间片内</li>
<li>如果进程没有在一个时间片内完成，它被移到队尾等待下一个轮到它的时间片</li>
</ul>
</li>
<li><strong>优先级调度</strong><ul>
<li>每个进程分配一个优先级</li>
<li>优先级最高的进程首先被执行</li>
<li>如果两个进程具有相同的优先级，则FCFS原则被应用</li>
<li>可能导致低优先级进程永远得不到执行（饥饿）</li>
</ul>
</li>
<li><strong>多级反馈队列 (Multilevel Feedback Queue)</strong><ul>
<li>结合了多种方法的优点</li>
<li>系统有多个队列，每个队列有不同的执行时间</li>
<li>进程开始时放在顶部队列，如果它没有在给定的时间片内完成，则被移动到下一个队列</li>
<li>这样，CPU密集型的进程最终会被移动到底部的队列，而I&#x2F;O密集型的进程会在顶部队列中被快速处理</li>
</ul>
</li>
<li><strong>最短剩余时间优先 (SRTF, Shortest Remaining Time First)</strong><ul>
<li>是SJF的抢先式版本</li>
<li>如果一个新的进程到达，其运行时间比当前正在执行的进程的剩余时间短，则挂起当前进程，并开始执行新进程</li>
</ul>
</li>
</ol>
</li>
</ol>
<h2 id="12-C-容器的底层实现"><a href="#12-C-容器的底层实现" class="headerlink" title="12.C++容器的底层实现"></a>12.C++容器的底层实现</h2><p>C++的STL（标准模板库）提供了一套功能丰富的容器类，这些容器使用了各种数据结构来高效地实现数据的存储和操作。以下是一些主要容器的底层实现简述：</p>
<ol>
<li><strong>std::vector</strong>：<ul>
<li><strong>底层实现</strong>：动态数组。</li>
<li><strong>特点</strong>：连续的内存块，支持O(1)的随机访问，但在中间插入或删除元素需要O(n)的时间。</li>
</ul>
</li>
<li><strong>std::list</strong>：<ul>
<li><strong>底层实现</strong>：双向链表。</li>
<li><strong>特点</strong>：插入和删除都是O(1)的操作，但随机访问需要O(n)的时间。</li>
</ul>
</li>
<li>**std::forward_list (C++11)**：<ul>
<li><strong>底层实现</strong>：单向链表。</li>
<li><strong>特点</strong>：只能向前迭代，与双向链表相比，单向链表使用更少的内存。</li>
</ul>
</li>
<li><strong>std::deque</strong>：<ul>
<li><strong>底层实现</strong>：数组的数组（即，一个中央控制块指向固定大小的块数组）。</li>
<li><strong>特点</strong>：在首尾插入和删除操作的时间复杂度都是O(1)，支持O(1)的随机访问。</li>
</ul>
</li>
<li><strong>std::stack &#x2F; std::queue</strong>：<ul>
<li><strong>底层实现</strong>：通常基于std::deque，但可以使用其他容器（如std::list）。</li>
<li><strong>特点</strong>：stack和queue只是容器适配器，它们提供了特定的接口（如push&#x2F;pop&#x2F;front&#x2F;back）。</li>
</ul>
</li>
<li><strong>std::priority_queue</strong>：<ul>
<li><strong>底层实现</strong>：通常基于std::vector，但实际上是一个二叉堆。</li>
<li><strong>特点</strong>：支持插入操作和获取最大元素（或最小元素，取决于比较函数）的操作。</li>
</ul>
</li>
<li><strong>std::set &#x2F; std::multiset</strong>：<ul>
<li><strong>底层实现</strong>：红黑树（一种自平衡的二叉搜索树）。</li>
<li><strong>特点</strong>：所有元素都会自动排序，插入、删除和查找操作的时间复杂度都是O(log n)。</li>
</ul>
</li>
<li><strong>std::map &#x2F; std::multimap</strong>：<ul>
<li><strong>底层实现</strong>：红黑树。</li>
<li><strong>特点</strong>：键值对自动按键排序，插入、删除和查找操作的时间复杂度都是O(log n)。</li>
</ul>
</li>
<li>**std::unordered_set &#x2F; std::unordered_multiset &#x2F; std::unordered_map &#x2F; std::unordered_multimap (C++11)**：<ul>
<li><strong>底层实现</strong>：哈希表。</li>
<li><strong>特点</strong>：在平均情况下，插入、删除和查找操作的时间复杂度都是O(1)；但在最坏情况下可能是O(n)。</li>
</ul>
</li>
</ol>
<h2 id="13-内存碎片"><a href="#13-内存碎片" class="headerlink" title="13.内存碎片"></a>13.内存碎片</h2><p>内存碎片大致分为两类：外部碎片和内部碎片。</p>
<ol>
<li><strong>外部碎片</strong>:<ul>
<li>描述：当内存中有很多小的空闲块，它们各自单独都不足以满足分配请求时，即使这些小块的总和可能足够，这种情况就产生了外部碎片。</li>
</ul>
</li>
<li><strong>内部碎片</strong>:<ul>
<li>描述：当分配给程序的内存块比实际所需的大时，超过的那部分内存就是内部碎片。</li>
</ul>
</li>
</ol>

        </article>
        <section class="post-near">
            <ul>
                
                    <li>上一篇: 看完啦 (つд⊂)</li>
                
                
                    <li>下一篇: <a href="/2023/05/10/stol-%E4%B8%8E-stoll%E5%87%BD%E6%95%B0/">stol 与 stoll函数</a></li>
                
            </ul>
        </section>
        
            <section class="post-tags">
            <a class="-none-link" href="/tags/%E9%9D%A2%E7%BB%8F-%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/" rel="tag">面经 项目经验</a>
            </section>
        
    
        <section class="post-author">
        
            <figure class="author-avatar">
                <img src="https://th.bing.com/th/id/R.d68f3556e3d9c56a0c459eafffa1eaea?rik=hNoYIA%2fQADAlpA&riu=http%3a%2f%2f5b0988e595225.cdn.sohucs.com%2fc_zoom%2ch_231%2fimages%2f20181105%2f270c5d2d0b584ffd85458ff865a1422b.png&ehk=QdGXn3jm3gWO%2fB3HAThLSoLqxed%2bmzpexulMD4FhFqA%3d&risl=&pid=ImgRaw&r=0" alt="SYX" />
            </figure>
        
            <div class="author-info">
                <h4>SYX</h4>
                <p>一只努力学习的小垃圾</p>
            </div>
        </section>
    
    </div>
</main>

    <footer>
    <div class="buttons">
        <a class="to-top" href="#"></a>
    </div>
    <div class="wrap min">
        <section class="widget">
            <div class="row">
                <div class="col-m-4">
                    <h3 class="title-recent">最新文章：</h3>
                    <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/09/15/%E5%8D%8E%E6%A9%99%E9%9D%A2%E7%BB%8F%E5%A4%B1%E8%B4%A5/">华橙面经失败</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/10/stol-%E4%B8%8E-stoll%E5%87%BD%E6%95%B0/">stol 与 stoll函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/18/memset-%E5%87%BD%E6%95%B0/">memset()函数</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/13/unordered-set%E4%B8%ADend-%E4%B8%8Efind-%E7%9A%84%E4%BD%BF%E7%94%A8/">unordered_set中end()与find()的使用</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/11/Cookie%E5%92%8CSession%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%88%E9%9D%A2%E8%AF%95%E5%BF%85%E5%A4%87%EF%BC%89/">Cookie和Session的区别（面试必备）</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/04/11/%E7%99%BE%E5%BA%A6C-%E5%AE%9E%E4%B9%A0%E7%94%9F%E7%AC%94%E8%AF%95/">百度C++实习生笔试</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-date">时光机：</h3>
                    <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives%20%20/%20%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E5%A4%B9/2023/09/">September 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives%20%20/%20%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E5%A4%B9/2023/05/">May 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives%20%20/%20%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E5%A4%B9/2023/04/">April 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives%20%20/%20%E5%BD%92%E6%A1%A3%E6%96%87%E4%BB%B6%E5%A4%B9/2023/03/">March 2023</a></li></ul>
                </div>
                <div class="col-m-4">
                    <h3 class="title-tags">标签云：</h3>
                    <a href="/tags/C/" style="font-size: 20px;">C++</a> <a href="/tags/C-%E7%AC%94%E8%AF%95/" style="font-size: 10px;">C++ 笔试</a> <a href="/tags/C-%E9%9D%A2%E8%AF%95/" style="font-size: 10px;">C++ 面试</a> <a href="/tags/C-11/" style="font-size: 10px;">C++11</a> <a href="/tags/STL-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 10px;">STL 数据结构</a> <a href="/tags/TCP/" style="font-size: 10px;">TCP</a> <a href="/tags/getline-%E5%87%BD%E6%95%B0/" style="font-size: 10px;">getline()函数</a> <a href="/tags/malloc%E5%87%BD%E6%95%B0/" style="font-size: 10px;">malloc函数</a> <a href="/tags/memset-%E5%87%BD%E6%95%B0/" style="font-size: 10px;">memset()函数</a> <a href="/tags/set%E5%A4%A9%E7%84%B6%E5%8E%BB%E9%87%8D/" style="font-size: 10px;">set天然去重</a> <a href="/tags/stol-stoll/" style="font-size: 10px;">stol() stoll()</a> <a href="/tags/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0-Lambda%E5%87%BD%E6%95%B0/" style="font-size: 10px;">匿名函数  Lambda函数</a> <a href="/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/" style="font-size: 10px;">哈希表</a> <a href="/tags/%E7%AC%94%E8%AF%95/" style="font-size: 10px;">笔试</a> <a href="/tags/%E7%AC%94%E8%AF%95-C/" style="font-size: 10px;">笔试 C++</a> <a href="/tags/%E8%81%94%E7%B3%BB%E6%96%B9%E5%BC%8F/" style="font-size: 10px;">联系方式</a> <a href="/tags/%E9%9D%A2%E7%BB%8F-%E9%A1%B9%E7%9B%AE%E7%BB%8F%E9%AA%8C/" style="font-size: 10px;">面经 项目经验</a> <a href="/tags/%E9%9D%A2%E8%AF%95-Cookie-Session/" style="font-size: 10px;">面试 Cookie Session</a>
                </div>
            </div>
        </section>
        <section class="sub-footer">
            <p>© 2023 <a href="/">小孙的blog</a>. All Rights Reserved. Theme By <a href="https://github.com/Dreamer-Paul/Hingle" target="_blank" rel="nofollow">Hingle</a>.</p>
        </section>
    </div>
</footer>


<script src="/static/kico.js"></script>
<script src="/static/hingle.js"></script>


<script>var hingle = new Paul_Hingle({"copyright":true,"night":true});</script>

  </body>
</html>
